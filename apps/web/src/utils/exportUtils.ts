import * as XLSX from 'xlsx';
import jsPDF from 'jspdf';
import html2canvas from 'html2canvas';
import { format } from 'date-fns';

export interface ExportData {
  title: string;
  data: any[];
  columns: { key: string; label: string; type?: 'string' | 'number' | 'currency' | 'percentage' }[];
  metadata?: {
    dateRange?: string;
    generatedBy?: string;
    organization?: string;
  };
}

export const formatValue = (value: any, type?: string): string => {
  if (value === null || value === undefined) return '';
  
  switch (type) {
    case 'currency':
      return `$${Number(value).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
    case 'percentage':
      return `${Number(value).toFixed(1)}%`;
    case 'number':
      return Number(value).toLocaleString();
    default:
      return String(value);
  }
};

export const exportToExcel = (exportData: ExportData, filename: string = 'report') => {
  // Create workbook
  const wb = XLSX.utils.book_new();
  
  // Create header rows with metadata
  const headerRows = [];
  headerRows.push([exportData.title]);
  headerRows.push(['']); // Empty row
  
  if (exportData.metadata) {
    if (exportData.metadata.dateRange) {
      headerRows.push(['Date Range:', exportData.metadata.dateRange]);
    }
    if (exportData.metadata.organization) {
      headerRows.push(['Organization:', exportData.metadata.organization]);
    }
    headerRows.push(['Generated:', format(new Date(), 'PPP')]);
    if (exportData.metadata.generatedBy) {
      headerRows.push(['Generated By:', exportData.metadata.generatedBy]);
    }
  }
  
  headerRows.push(['']); // Empty row before data
  
  // Create column headers
  const columnHeaders = exportData.columns.map(col => col.label);
  
  // Format data rows
  const dataRows = exportData.data.map(row => 
    exportData.columns.map(col => {
      const value = row[col.key];
      return col.type === 'currency' || col.type === 'percentage' 
        ? formatValue(value, col.type)
        : value;
    })
  );
  
  // Combine all rows
  const allRows = [
    ...headerRows,
    columnHeaders,
    ...dataRows
  ];
  
  // Create worksheet
  const ws = XLSX.utils.aoa_to_sheet(allRows);
  
  // Set column widths
  const colWidths = exportData.columns.map(col => ({ wch: 20 }));
  ws['!cols'] = colWidths;
  
  // Add worksheet to workbook
  XLSX.utils.book_append_sheet(wb, ws, 'Report');
  
  // Generate filename with timestamp
  const timestampedFilename = `${filename}_${format(new Date(), 'yyyy-MM-dd_HH-mm')}.xlsx`;
  
  // Save file
  XLSX.writeFile(wb, timestampedFilename);
};

export const exportToPDF = async (
  elementId: string, 
  title: string, 
  orientation: 'portrait' | 'landscape' = 'landscape',
  filename: string = 'report'
) => {
  const element = document.getElementById(elementId);
  if (!element) return;
  
  // Create a clone to modify for PDF
  const clonedElement = element.cloneNode(true) as HTMLElement;
  clonedElement.style.backgroundColor = 'white';
  clonedElement.style.color = '#000';
  
  // Apply print-friendly styles
  const printStyles = `
    * { 
      color: #000 !important; 
      background-color: transparent !important;
    }
    .bg-\\[\\#333333\\] { background-color: #f5f5f5 !important; }
    .text-white { color: #000 !important; }
    .text-gray-400 { color: #666 !important; }
    .border-\\[\\#1E1E1E\\] { border-color: #ddd !important; }
    .text-\\[\\#336699\\] { color: #336699 !important; }
    .text-\\[\\#388E3C\\] { color: #388E3C !important; }
    .text-\\[\\#D32F2F\\] { color: #D32F2F !important; }
    .text-\\[\\#F9D71C\\] { color: #F9D71C !important; }
  `;
  
  // Temporarily append to body
  const container = document.createElement('div');
  container.style.position = 'absolute';
  container.style.left = '-9999px';
  container.style.width = orientation === 'landscape' ? '1100px' : '800px';
  
  const styleEl = document.createElement('style');
  styleEl.textContent = printStyles;
  container.appendChild(styleEl);
  container.appendChild(clonedElement);
  document.body.appendChild(container);
  
  try {
    const canvas = await html2canvas(clonedElement, {
      backgroundColor: '#ffffff',
      scale: 2,
      logging: false,
      useCORS: true
    });
    
    const imgData = canvas.toDataURL('image/png');
    
    // Calculate dimensions
    const imgWidth = orientation === 'landscape' ? 280 : 210;
    const pageHeight = orientation === 'landscape' ? 210 : 297;
    const imgHeight = (canvas.height * imgWidth) / canvas.width;
    
    // Create PDF
    const pdf = new jsPDF({
      orientation,
      unit: 'mm',
      format: 'a4'
    });
    
    let heightLeft = imgHeight;
    let position = 10;
    
    // Add title
    pdf.setFontSize(16);
    pdf.text(title, 15, position);
    position += 10;
    
    // Add metadata
    pdf.setFontSize(10);
    pdf.text(`Generated: ${format(new Date(), 'PPP')}`, 15, position);
    position += 10;
    
    // Add image
    pdf.addImage(imgData, 'PNG', 15, position, imgWidth - 30, imgHeight);
    heightLeft -= pageHeight;
    
    // Add pages if needed
    while (heightLeft >= 0) {
      position = heightLeft - imgHeight + 10;
      pdf.addPage();
      pdf.addImage(imgData, 'PNG', 15, position, imgWidth - 30, imgHeight);
      heightLeft -= pageHeight;
    }
    
    // Save PDF
    const timestampedFilename = `${filename}_${format(new Date(), 'yyyy-MM-dd_HH-mm')}.pdf`;
    pdf.save(timestampedFilename);
    
  } finally {
    // Clean up
    document.body.removeChild(container);
  }
};

export interface ScheduledReportConfig {
  id?: string;
  name: string;
  type: 'excel' | 'pdf';
  frequency: 'daily' | 'weekly' | 'monthly';
  dayOfWeek?: number; // 0-6 for weekly
  dayOfMonth?: number; // 1-31 for monthly
  time: string; // HH:mm format
  recipients: string[];
  includeCategories?: string[];
  dateRange: 'last7days' | 'last30days' | 'lastMonth' | 'lastQuarter' | 'lastYear';
  isActive: boolean;
}

export const saveScheduledReport = async (config: ScheduledReportConfig, userId: string) => {
  // This would save to Supabase
  // For now, just save to localStorage as a demo
  const reports = JSON.parse(localStorage.getItem('scheduledReports') || '[]');
  const newReport = {
    ...config,
    id: config.id || Date.now().toString(),
    userId,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  };
  
  if (config.id) {
    const index = reports.findIndex((r: any) => r.id === config.id);
    if (index !== -1) {
      reports[index] = newReport;
    }
  } else {
    reports.push(newReport);
  }
  
  localStorage.setItem('scheduledReports', JSON.stringify(reports));
  return newReport;
};

export const getScheduledReports = (userId: string): ScheduledReportConfig[] => {
  const reports = JSON.parse(localStorage.getItem('scheduledReports') || '[]');
  return reports.filter((r: any) => r.userId === userId);
};

export const deleteScheduledReport = (reportId: string) => {
  const reports = JSON.parse(localStorage.getItem('scheduledReports') || '[]');
  const filtered = reports.filter((r: any) => r.id !== reportId);
  localStorage.setItem('scheduledReports', JSON.stringify(filtered));
}; 